%This file contains the LaTeX code of my Y86 Simulator report for my ICS course.
%Author: 章凌豪/Zhang Linghao <zlhdnc1994@gmail.com>

\section{Discussion}

\subsection{Memory Issues}

分页内存的实现主要是考虑到可能出现栈指针减过$0$从而下溢出的情形。因为我认为这种情况下简单地报错并不合适，所以对地址取了Unsigned。但这又使得地址成为一个很大的值，从而导致数组范围过大，消耗大量内存甚至使浏览器进程崩溃。

实现了分页内存后，这个问题并没有迎刃而解，因为这个问题虽然在逻辑部分很容易解决，但在显示部分就没有一个太好的方案。假如在0x100附近和0xFFFFFFF0附近有一些内存被修改了，因为它们被分到不同的页，所以在显示时就有两种选择：一是分页显示，二是只显示有效的内存值。然而后者需要记录哪些内存是有效的，这显然不是一个具有扩展性的好方法；但前者不够直观，而且在页数变大时也面临过度消耗资源的问题。所以最后出于前端性能考虑，只显示前$1024$位内存。同时在测试中，我都手动将栈指针指定到0x200的位置，这样更便于展示栈指针的移动。

\subsection{Disassembler Issues}

在编写Y86反汇编器时遇到的一个大问题就是如何区分指令和数据。在尝试、查阅、讨论和权衡后，我决定不试图在反汇编器中实现对指令和数据的区分。在最终的实现中，反编译器会试图将每行目标码都当做指令去解析。假设一行目标码本应是数据，如果将其作为指令能解析成功，则继续；如果解析失败，则将其记录下来，并在反汇编的结果最后注明这可能是因为遇到了数据区域。

这么做的主要理由是，对于Y86这种{\bf 指令和数据可以任意混合}的汇编语言，不存在一个可行的办法对两者进行区分。因为不管是采用静态分析还是动态分析，要判断一行目标码是否属于一条指令，只能判断它是否能被执行到，而这就{\bf 与停机问题等价}。虽然在小规模的情况下可以通过暴力算法解决，但这样做相当于在程序中留下了一个隐患。

再就是对于反汇编来说，将数据误解析成指令是不可避免的，处理这种情况其实已经{\bf 超出了反汇编器的工作范围}。常见的反汇编工具（如{\bf objdump}），则是因为其处理的格式（如{\bf ELF}格式）对指令区域和数据区域的编排是有规范的。

所以这个问题只能通过为Y86汇编语言制定类似的规范或者接受一个不保证能停止的算法来解决。基于以上考虑我决定不试图处理这种情况。

\subsection{Limitation of Cache}

在测试中，Cache Hit Rate基本在$25\%$左右。而在现实中CPU的L1 Cache往往有$95\%$的Cache Hit Rate。这之间的差异主要在于我实现的L1 Cache简化版只能容纳$32B$数据，而现代CPU的L1 Cache往往是这个大小的上百倍，如Pentium 4处理器的L1 Cache就有$8KB$。当然从另一个角度看也可以证明缓存机制的效用之高：{\bf 我只是根据缓存的相关概念和原理用极其简单的数据结构和策略进行了实现，就能达到可观的命中率。}

我这么选择主要是由于在当初实现时考虑到一个Set里有超过两条Line或者一条Line里有超过两个Block会带来一些代码上的复杂度，加上缓存策略的实现也颇为繁杂，容易出现难以调试的bug。而在将缓存正确实现后，由于还要实现其他的功能，加上时间原因，没能再对这部分进行改动。如果将Set的数量改为$4$个并增加Block的数量，缓存命中率应该还能提高不少。

\subsection{Limitation of Test Cases}

如第四节中所言，本次Project中进行的测试所能覆盖的情况有限。如果有时间，可以多编写一些代码来进行测试。

不过由于在开发过程中{\bf 大量使用闭包、匿名函数、封装和解耦}，代码的可靠性还是很高的，在有可能导致程序崩溃的地方都做了限制，不容易Crash。主要还是需要更复杂的{\bf Hazard Combination}和{\bf Corner Cases}来验证程序的逻辑和交互正确性。

\subsection{Customized Instructions}