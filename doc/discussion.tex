%This file contains the LaTeX code of my Y86 Simulator report for my ICS course.
%Author: 章凌豪/Zhang Linghao <zlhdnc1994@gmail.com>

\section{Discussion}

本节将对设计和开发过程中遇到的一些问题、做出的一些取舍，以及目前的实现存在的一些局限性进行讨论。

\subsection{Memory Issues}

分页内存的实现主要是考虑到可能出现栈指针减过$0$从而下溢出的情形。因为我认为这种情况下简单地报错并不合适，所以对地址取了Unsigned。但这又使得地址成为一个很大的值，从而导致数组范围过大，消耗大量内存甚至使浏览器进程崩溃。

实现了分页内存后，这个问题并没有迎刃而解，因为这个问题虽然在逻辑部分很容易解决，但在显示部分就没有一个太好的方案。假如在0x100附近和0xFFFFFFF0附近有一些内存被修改了，因为它们被分到不同的页，所以在显示时就有两种选择：一是分页显示，二是只显示有效的内存值。然而后者需要记录哪些内存是有效的，这显然不是一个具有扩展性的好方法；但前者不够直观，而且在页数变大时也面临过度消耗资源的问题。所以最后出于前端性能考虑，只显示前$1024$位内存。同时在测试中，我都手动将栈指针指定到0x200的位置，这样更便于展示栈指针的移动。

\subsection{Disassembler Issues}

在编写Y86反汇编器时遇到的一个大问题就是如何区分指令和数据。在尝试、查阅、讨论和权衡后，我决定不试图在反汇编器中实现对指令和数据的区分。在最终的实现中，反编译器会试图将每行目标码都当做指令去解析。假设一行目标码本应是数据，如果将其作为指令能解析成功，则继续；如果解析失败，则将其记录下来，并在反汇编的结果最后注明这可能是因为遇到了数据区域。

这么做的主要理由是，对于Y86这种{\bf 指令和数据可以任意混合}的汇编语言，不存在一个可行的办法对两者进行区分。因为不管是采用静态分析还是动态分析，要判断一行目标码是否属于一条指令，只能判断它是否能被执行到，而这就{\bf 与停机问题等价}。虽然在小规模的情况下可以通过暴力算法解决，但这样做相当于在程序中留下了一个隐患。

再就是对于反汇编来说，将数据误解析成指令是不可避免的，处理这种情况其实已经{\bf 超出了反汇编器的工作范围}。常见的反汇编工具（如{\bf objdump}），则是因为其处理的格式（如{\bf ELF}格式）对指令区域和数据区域的编排是有规范的。

所以这个问题只能通过为Y86汇编语言制定类似的规范或者接受一个不保证能停止的算法来解决。基于以上考虑我决定不试图处理这种情况。

\subsection{Limitation of Cache}

在测试中，Cache Hit Rate基本在$25\%$左右。而在现实中CPU的L1 Cache往往有$95\%$的Cache Hit Rate。这之间的差异主要在于我实现的L1 Cache简化版只能容纳$32B$数据，而现代CPU的L1 Cache往往是这个大小的上百倍，如Pentium 4处理器的L1 Cache就有$8KB$。当然从另一个角度看也可以证明缓存机制的效用之高：{\bf 我只是根据缓存的相关概念和原理用极其简单的数据结构和策略进行了实现，就能达到可观的命中率。}

我这么选择主要是由于在当初实现时考虑到一个Set里有超过两条Line或者一条Line里有超过两个Block会带来一些代码上的复杂度，加上缓存策略的实现也颇为繁杂，容易出现难以调试的bug。而在将缓存正确实现后，由于还要实现其他的功能，加上时间原因，没能再对这部分进行改动。如果将Set的数量改为$4$个并增加Block的数量，缓存命中率应该还能提高不少。

\subsection{Limitation of Test Cases}

如第四节中所言，本次Project中进行的测试所能覆盖的情况有限。如果有时间，可以多编写一些代码来进行测试。

不过由于在开发过程中{\bf 大量使用闭包、匿名函数、封装和解耦}，代码的可靠性还是很高的，在有可能导致程序崩溃的地方都做了限制，不容易Crash。主要还是需要更复杂的{\bf Hazard Combination}和{\bf Corner Cases}来验证程序的逻辑和交互正确性。

\subsection{Customized Instructions}

在实现模拟器的大部分功能之后，我试着添加了一条新指令IADDL，即将一个寄存器的值加上一个立即数。同时我将为模拟器添加新的自定义指令的步骤归纳如下：

\begin{enumerate}
\item 分析和列出要添加的新指令在每个阶段需要完成的操作。
\item 在{\bf js/constants.js}中定义用于代表新指令的常量。
\item 在{\bf js/kernel.js}中流水线的各个阶段做对应的修改：
\item $fetch$：将指令加入合法指令列表，并根据需求在抽取$rA:rB$和$valC$时将其添加到判断列表中。
\item $decode$：在设置$E\_srcA$等一系列流水线寄存器的值时，将指令添加到对应情形的判断列表中。这里主要分为数据运算和移动以及调用栈这两类情形。
\item $execute$：同理，在设置$ALU.inputA$和$ALU.inputB$时，根据情形添加指令。如果指令涉及运算，不要忘记$setCC$；如果指令可能成为Hazard Cause，不要忘记增加对该指令的计数。
\item $memory$：判断指令是否要读写内存，并进行相应读写操作。
\item $write\_back$：不需要做任何修改。
\item $pipeline_control_logic$：用与课本上类似的方法分析指令可能触发何种Hazard，并将其添加到对应的处理列表中。同样不要忘记增加计数。
\item 在{\bf js/assembler.js}中的几个常量数组中添加指令对应的条目；在$insSyntax$和$insEncoder$中分别添加指令的语法以及转换函数。由于其他函数与具体指令无关，所以不需要再做修改。以IADDL为例，有$insSyntax['iaddl'] = ['V', 'rB']$和$insEncoder['iaddl'] = 'c08' + this.rB + this.V$。
\item 在{\bf js/disassembler.js}中做与上述类似的修改。以IADDL为例，有$codeSyntax['iaddl'] = ['rA', 'rB', 'V']$和$insDecoder['iaddl'] = this.ins + ' \$0x' + this.V + ', ' + this.rB$。
\end{enumerate}

可以看出，在自定义新指令时，只要{\bf 将其每个阶段的操作分析出来}，修改流水线逻辑是很方便的。同时对汇编器和反汇编器的修改也由于{\bf 良好的封装和低耦合}而极为便捷。

由于时间原因，再加上这纯粹是重复性的机械劳动，我没有进一步添加更多的新指令。